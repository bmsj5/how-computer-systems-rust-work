# How Rust Code Becomes Assembly: The Full Pipeline

## The Question: "How does Rust become assembly?"

**Answer:** Rust uses a **multi-stage compilation pipeline** with LLVM as the backend.

## The Full Pipeline

```
┌─────────────────────────────────────────────────────────┐
│ Stage 1: Rust Source Code                              │
│   (Your .rs files)                                      │
└─────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────┐
│ Stage 2: Rust Compiler (rustc)                          │
│   - Parses Rust code                                     │
│   - Type checking                                        │
│   - Builds symbol tables (HashMap in RAM)               │
│   - Generates LLVM IR (Intermediate Representation)     │
└─────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────┐
│ Stage 3: LLVM IR (Intermediate Representation)          │
│   - Platform-independent code                            │
│   - Still high-level (not assembly yet)                 │
│   - Looks like: %1 = add i32 %0, 1                     │
└─────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────┐
│ Stage 4: LLVM Backend                                   │
│   - Optimizes LLVM IR                                    │
│   - Converts to target-specific assembly                │
│   - Generates: mov eax, 5                               │
└─────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────┐
│ Stage 5: Assembler                                      │
│   - Converts assembly → machine code                    │
│   - Generates binary file                                │
└─────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────┐
│ Stage 6: Linker                                         │
│   - Links with standard library                          │
│   - Creates final executable                            │
└─────────────────────────────────────────────────────────┘
```

## What rustc Actually Does

### rustc's Job:
1. **Parse** Rust code → Abstract Syntax Tree (AST)
2. **Type check** → Ensure types are correct
3. **Build symbol tables** → HashMap in RAM
4. **Generate LLVM IR** → Platform-independent code
5. **Call LLVM** → Convert IR to assembly
6. **Call assembler** → Convert assembly to binary
7. **Call linker** → Create final executable

### rustc Does NOT Generate Assembly Directly!

**rustc generates LLVM IR, then LLVM generates assembly.**

## Example: Your Code Transformation

### Stage 1: Your Rust Code
```rust
fn compile_function() {
    let mut symbol_table: HashMap<String, Symbol> = HashMap::new();
    let mut current_offset = 0;
    current_offset -= 1;
    symbol_table.insert("x".to_string(), Symbol {
        offset: current_offset,  // -1
        size: 1,
    });
}
```

### Stage 2: LLVM IR (Generated by rustc)
```llvm
; LLVM IR (what rustc generates)
define void @compile_function() {
  %symbol_table = alloca %HashMap
  %current_offset = alloca i32
  store i32 0, i32* %current_offset
  %1 = load i32, i32* %current_offset
  %2 = sub i32 %1, 1
  store i32 %2, i32* %current_offset
  ; ... more code ...
}
```

### Stage 3: Assembly (Generated by LLVM)
```asm
; Assembly (what LLVM generates)
compile_function:
  pushq %rbp
  movq %rsp, %rbp
  subq $32, %rsp        ; Allocate stack space
  movl $0, -4(%rbp)     ; current_offset = 0
  movl -4(%rbp), %eax
  subl $1, %eax         ; current_offset -= 1
  movl %eax, -4(%rbp)
  ; ... more code ...
```

### Stage 4: Machine Code (Generated by Assembler)
```
Binary bytes:
[0x55] [0x48] [0x89] [0xE5] [0x48] [0x83] [0xEC] [0x20] ...
 ↑      ↑      ↑      ↑
 │      │      │      └─ movq %rsp, %rbp
 │      │      └─ pushq %rbp
 │      └─ Machine code bytes
 └─ Opcodes
```

## Why LLVM?

### rustc Uses LLVM Because:
1. **Platform independence**: Write once, compile to many targets
2. **Optimization**: LLVM has world-class optimizers
3. **Mature**: LLVM is battle-tested
4. **Reusable**: Many languages use LLVM (Rust, Swift, Julia, etc.)

### LLVM Architecture:
```
┌─────────────┐
│ rustc       │ → Generates LLVM IR
└─────────────┘
      ↓
┌─────────────┐
│ LLVM        │ → Optimizes IR
│ (Backend)   │ → Generates assembly for target CPU
└─────────────┘
      ↓
┌─────────────┐
│ Assembler   │ → Converts assembly to binary
└─────────────┘
```

## How to See Each Stage

### 1. See LLVM IR:
```bash
rustc --emit=llvm-ir src/main.rs -o main.ll
```

### 2. See Assembly:
```bash
rustc --emit=asm src/main.rs -o main.s
```

### 3. See Machine Code:
```bash
rustc src/main.rs -o main
objdump -d main  # Disassemble binary
```

## The Key Insight

**rustc doesn't "magically" turn Rust into assembly.**

Instead:
1. **rustc** (written in Rust) parses your code
2. **rustc** generates **LLVM IR** (intermediate representation)
3. **LLVM** (written in C++) converts IR to assembly
4. **Assembler** converts assembly to machine code

**It's a pipeline of tools, not magic!**

## Summary

| Stage | Tool | Input | Output |
|-------|------|-------|--------|
| 1 | rustc (parser) | Rust code | AST |
| 2 | rustc (type checker) | AST | Typed AST |
| 3 | rustc (codegen) | Typed AST | LLVM IR |
| 4 | LLVM (optimizer) | LLVM IR | Optimized IR |
| 5 | LLVM (backend) | Optimized IR | Assembly |
| 6 | Assembler | Assembly | Machine code |
| 7 | Linker | Machine code + libs | Executable |

## Why This Matters

- **rustc** is a **frontend** (Rust → LLVM IR)
- **LLVM** is a **backend** (LLVM IR → Assembly)
- **Separation of concerns**: rustc handles Rust-specific stuff, LLVM handles optimization and code generation

This is why rustc can target many platforms (x86, ARM, RISC-V, etc.) — LLVM handles the platform-specific code generation!
